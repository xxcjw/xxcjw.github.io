[{"content":"学技术前先读史，对后续有很帮助。下面介绍一下统计语言模型发展史。\nN-gram 模型 其预测下一个词语的核心思想如下：\n$$ P(w_n|w_1, w_2, \\ldots, w_{n - 1}) $$ 即下一个词语出现的概率取决于在句子中出现在它之前的所有词，但是，随着文本长度的增加，条件概率会变得越来越难以计算，因而在实际计算时会假设每个词语仅与它前面的N−1个词语有关，即\n$$ P(w_i | w_1, w_2, \\ldots, w_{i - 1}) = P(w_i | w_{i - N + 1}, w_{i - N + 2}, \\ldots, w_{i - 1}) $$ 这种假设被称为马尔可夫（Markov）假设，对应的语言模型被称为 N 元（N-gram）模型。比如N=2时基于前一个单词预测当前单词；N=3时考虑前两个单词来预测当前单词；而N=1时，模型实际上就是一个上下文无关模型。\n通过统计语料库中 n - gram 序列的频率，估计给定前 n - 1 个元素后下一个元素出现的概率 ，从而选择概率最高的词作为预测结果。例如，在语料库中统计 “我喜欢” 后面接不同词的频率，若 “苹果” 出现次数最多，当输入 “我喜欢” 时，就可能预测下一个词是 “苹果” 。\nNNLM 模型 NNLM 模型的思路与统计语言模型保持一致，它通过输入词语前面的N−1个词语来预测当前词。其结构如图所示：\n具体来说，模型首先从词表C中查询得到前面N-1个词语对应的词向量，然后将这些词向量拼接后输入到带有激活函数的隐藏层中，通过Softmax函数预测当前词语的概率。特别地，包含所有词向量的词表矩阵 C 也是模型的参数，需要通过学习获得。\nWord2Vec 模型 真正将神经网络语言模型发扬光大的模型，Word2Vec 模型提供的词向量在很长一段时间里都是自然语言处理方法的标配。Word2Vec 的模型结构和 NNLM 基本一致，只是训练方法有所不同，分为 CBOW (Continuous Bag-of-Words) 和 Skip-gram 两种。\n其中 CBOW 使用周围的词语w(t-2),w(t-1),w(t+1),w(t+2)来预测当前词w(t)，而 Skip-gram 则正好相反，它使用当前词w(t)来预测它的周围词语。Word2Vec 模型训练目标也更多地是为获得词向量服务。特别是同时通过上文和下文来预测当前词语的 CBOW 训练方法打破了语言模型“只通过上文来预测当前词”的固定思维。\n通过将词汇表中的单词转换成高维空间向量来表示语义关系，为自然语言处理提供了有效的文本数值化方式，推动了深度学习在 NLP 领域的应用。\n数据：比如窗口大小设为 2，对于句子 “我 爱 自然 语言 处理” ，以 “自然” 为中心词，上下文词是 “我”“爱”“语言”“处理” 初始化：为每个单词初始化一个随机词向量 计算预测：CBOW 将上下文词向量相加输入隐藏层再到输出层，Skip - gram 则是将目标词向量输入隐藏层再到输出层，输出层都用 softmax函数计算词汇表中每个词作为预测结果的概率 更新权重：根据预测结果和真实标签计算损失，通过反向传播算法使损失最小化，不断迭代优化词向量 ELMo 模型 为了更好地解决多义词问题，提出了 ELMo 模型（Embeddings from Language Models）。与 Word2Vec 模型只能提供静态词向量不同，ELMo 模型会根据上下文动态地调整词语的词向量。\n具体来说，ELMo 模型首先对语言模型进行预训练，使得模型掌握编码文本的能力；然后在实际使用时，对于输入文本中的每一个词语，都提取模型各层中对应的词向量拼接起来作为新的词向量。ELMo 模型采用双层双向 LSTM 作为编码器，从两个方向编码词语的上下文信息，相当于将编码层直接封装到了语言模型中。\n训练完成后 ELMo 模型不仅学习到了词向量，还训练好了一个双层双向的 LSTM 编码器。对于输入文本中的词语，可以从第一层 LSTM 中得到包含句法信息的词向量，从第二层 LSTM 中得到包含语义信息的词向量，最终通过加权求和得到每一个词语最终的词向量。\n但是 ELMo 模型存在两个缺陷：首先它使用 LSTM 模型作为编码器，而不是当时已经提出的编码能力更强的 Transformer 模型；其次 ELMo 模型直接通过拼接来融合双向抽取特征的做法也略显粗糙。\n不久之后，将 ELMo 模型中的 LSTM 更换为 Transformer 的GPT、Bert模型就出现了。\nBERT 模型 2018 年底随着 BERT 模型（Bidirectional Encoder Representations from Transformers）的出现，这一阶段神经网络语言模型的发展终于出现了一位集大成者。\nBERT 模型采用和 GPT 模型类似的两阶段框架，首先对语言模型进行预训练，然后通过微调来完成下游任务。但是，BERT 不仅像 GPT 模型一样采用 Transformer 作为编码器，而且采用了类似 ELMo 模型的双向语言模型结构。因此 BERT 模型不仅编码能力强大，而且对各种下游任务，BERT 模型都可以通过简单地改造输出部分来完成。\n但是 BERT 模型的优点同样也是它的缺陷，由于 BERT 模型采用双向语言模型结构，因而无法直接用于生成文本。\n在 BERT 模型取得成功之后，在其基础上又提出了诸如RoBERTa等改良模型，其中具有代表性的就是微软提出的UNILM模型（可以使Bert具备生成能力），它把 BERT 模型的 MASK 机制运用到了一个很高的水平。\nBERT不能直接用于生成文本，原因如下：\n掩码语言模型（Masked Language Model, MLM）：BERT 通过随机遮盖文本中 15% 的 token，让模型根据上下文来预测被遮盖的词。这种训练方式让模型学会融合双向上下文信息理解语义，使其在理解上下文语义时表现优异。\n但也导致了一个关键问题——生成任务需要单向、逐步的预测。通常是自回归的，即逐词生成，每个新词的预测只能依赖已生成的左侧上下文。而BERT的双向机制在生成时会引入未来信息，导致信息泄露，与实际生成过程矛盾。不像自回归模型，如 GPT 那样从左到右依次根据前面生成的内容预测下一个词，所以难以直接用于文本生成任务。\nEncoder-only模型：BERT 架构只采用了 Transformer 的编码器部分，没有使用Transformer 解码器那样具备处理生成任务的结构设计。生成任务通常需要解码器逐步生成输出，按照顺序逐步生成下一个词，而 BERT 编码器缺乏这种从左到右、顺序生成的机制 。\n补充知识 LLM分类 一般分为三种：自回归模型、自编码模型和序列到序列模型。\n自回归（Autoregressive model）模型：decoder-only模型。采用经典的语言模型任务进行预训练，即给出上文，预测下文，对应原始Transformer模型的解码器部分，其中代表模型是GPT系列。模型一般会用于NLG的任务，如文本生成。 自编码（AutoEncoder model）模型：encoder-only模型。采用句子重建进行预训练，即预先通过某种方式破坏句子，掩码或打乱顺序，希望模型将被破坏的部分还原，对应原始Transformer模型的编码器部分，其中代表模型是BERT系列。与自回归模型不同，模型既可以看到上文信息，也可以看到下文信息，由于这样的特点，模型往往适用于NLU的任务，如文本分类、阅读理解等。 序列到序列（Sequence to Sequence Model）模型：则是同时使用了原始的编码器与解码器。这种模型最自然的应用便是文本摘要、机器翻译等任务，事实上基本所有的NLP任务都可以通过序列到序列解决。 NLG - 自然语言生成；NLU - 自然语言理解\nTransformer结构 标准的 Transformer 模型主要由两个模块构成：\nEncoder：负责理解输入文本，为每个输入构造对应的语义表示 Decoder：负责生成输出，使用 Encoder 输出的语义表示结合其他输入来生成目标序列 这两个模块可以根据任务的需求而单独使用：\n纯 Encoder 模型：适用于只需要理解输入语义的任务，例如句子分类、命名实体识别 纯 Decoder 模型：适用于生成式任务，例如文本生成 Encoder-Decoder 模型或 Seq2Seq：适用于需要基于输入的生成式任务，例如翻译、摘要 Transformer 模型本来是为了翻译任务而设计的。在训练过程中，Encoder 接受源语言的句子作为输入，而 Decoder 则接受目标语言的翻译作为输入。在 Encoder 中，由于翻译一个词语需要依赖于上下文，因此注意力层可以访问句子中的所有词语；而 Decoder 是顺序地进行解码，在生成每个词语时，注意力层只能访问前面已经生成的单词。\n例如，假设翻译模型当前已经预测出了三个词语，我们会把这三个词语作为输入送入 Decoder，然后 Decoder 结合 Encoder 所有的源语言输入来预测第四个词语。\n实际训练中为了加快速度，会将整个目标序列（真实值）都送入 Decoder，然后在注意力层中通过 Mask 遮盖掉未来的词语来防止信息泄露。因为若按顺序一个词一个词输入，效率很低。一次性输入整个目标序列，模型可以并行处理计算，大大加快训练速度 。\n其中，Decoder 中的第一个注意力层关注 Decoder 过去所有的输入，而第二个注意力层则是使用 Encoder 的输出，因此 Decoder 可以基于整个输入句子来预测当前词语。这对于翻译任务非常有用。\n在 Encoder/Decoder 的注意力层中，我们还会使用 Attention Mask 遮盖掉某些词语来防止模型关注它们，例如为了将数据处理为相同长度而向序列中添加的填充 (padding) 字符。\n总结 \u0026amp; 参考 可以看出，预测下一个词模型的基本范式都是学习融合上下文信息的每个词的嵌入表征，然后通过输出层（通常接 softmax 函数 ，维度大小是词库大小）计算词汇表中每个词作为下一个词的概率，从中选择概率最高的词或通过一定采样策略（如多项分布采样 ）确定下一个词。\n以 GPT 为例，它是自回归模型，从左到右依次根据已有的词预测下一个词 ；而 BERT 虽然主要用于完形填空任务（掩码语言模型），但也可以在微调后用于预测下一个词等生成任务 。\nTransformers-第一章\nTransformers-第二章\n","date":"2025-04-12T12:04:52+08:00","permalink":"https://xxcjw.github.io/p/llm%E7%B3%BB%E5%88%97-1nlp%E7%9A%84%E5%8F%91%E5%B1%95/","title":"LLM系列-1：NLP的发展"},{"content":"git设置代理 开vpn之后，当你还在为能正常打开Github、Youtobe而窃喜时，不知道你是否也遇到过这种情况：\n但当你使用git工具将本地代码文件上传Github时，却总是出现Failed to connect to github.com port 443: Timed out或者OpenSSL SSL_read: Connection was reset, errno 10054等git push失败的情况，让人火大。 或者发现git clone命令速度特别慢，有时还经常卡掉，这很让人着急。 总之，就四个字：失败、火大！于是搜各种教程，经过各种折腾，终于找到解决方案，归根结底还是因为代理设置的不正确！！！本文记录一下解决的方案。\n问题描述 简单来说，就是所使用的vpn正常，但是上传或下载Github文件时就很慢很卡，甚至连接不上出现报错情况。如果遇到这种情况，可以使用下面的方法解决。\n如果检查自己的vpn是否正常呢？有两种简单办法\n最简单的当然就是打开一个国外网站，比如YouTube等，如果能打开，证明梯子没问题； 另一种，就是win+r打开命令行，输入ping github.com看看能不能连上要使用的Github； 解决方法 遇到上述问题，就是代理设置不正确。可以通过以下命令查看和设置理。\n1、代理查询\n查看自己是否以前设置过代理，在CMD中输入以下命令进行查询\n1 2 git config --global http.proxy git config --global https.proxy 如果没有记录显示，则说明本电脑还没有配置过代理，否则需要先将代理进行删除，再进行后续的重新添加。\n2、代理取消\n如果执行上述代码之后，发现有代理存在，则执行下述命令，先将代理取移除\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy git config 是 Git 用于配置和管理各种参数的命令，可以设置和修改与 Git 相关的配置选项。\nhttp.proxy 是用于设置 Git 在进行 HTTP 或 HTTPS 连接时使用的代理服务器。\n3、代理设置\n首先需要获取当前所使用vpn的代理服务器地址，格式为：127.0.0.1:xxxx（我的是7879）。这里一定要注意，不要照抄网上的端口号，需要根据自己的服务器进行修改，否则报错。得到代理服务器地址之后，使用如下命令配置代理\n1 2 git config --global https.proxy 127.0.0.1:7897 git config --global http.proxy 127.0.0.1:7897 如何知道自己的代理服务器地址呢？两种办法：\n一是通过自己的vpn查看，打开自己的vpn-设置-端口设置/端口号的选项，这个就是代理服务器的端口 打开电脑的控制面板-网络和Internet-Internet选项-连接-局域网设置，然后就可以看到代理服务器的地址了，见图 通过这两种方式得到的应该是一样的。\n然后就配置成功了！就可以成功上传和下载文件了。需要注意的是，有少数人刚配置后，效果显著，但用一段时间之后，发现git push上传文件时仍然失败，这时候按照第二个步骤将代理重新取消掉就好了，如果有过一段时间又不行了，在重新配置就行，这样反复操作可以解决，但为什么这样不得而知。\n原理介绍 代理服务器就是你的电脑和互联网的中介。当您访问外网时 , 你的请求首先转发到代理服务器，然后代理服务器替你访问外网，并将结果原封不动的给你的电脑，这样你的电脑就可以看到外网的内容啦。\n使用vpn后无法正常上网 解决方法 很多同学使用vpn访问外网，但当关闭VPN后，却发现没有办法正常连接到互联网了。解决方法如下：\n1 控制面板--\u0026gt;网络和Internet--\u0026gt;Internet选项--\u0026gt;弹出的Internet属性窗口--\u0026gt;连接--\u0026gt;局域网设置 将为LAN使用代理服务器（这些设置不用于拨号或VPN连接）前面的√取消掉可以了（开vpn的时候勾上是正常的，如果关掉vpn后能正常上网就不用取消）。到此为止不出意外就可以正常上网啦！\n原因分析 一句话：可能是由于VPN代理软件修改了电脑IP地址的获取方式。\n通常情况下，计算机的IP地址是通过动态主机配置协议（DHCP）从您的路由器或网络提供商的服务器上获取的。使用VPN代理软件时，它会在您的计算机和互联网之间创建一个安全的连接。在这种连接中，VPN软件会通过在您的计算机和VPN服务器之间建立虚拟通道来代理您的网络流量。当您的网络流量通过VPN服务器时，服务器会为您的流量分配一个新的IP地址。\n通过这些步骤，VPN代理软件成功修改了您计算机的IP地址获取方式。现在，计算机使用的是VPN服务器分配的IP地址，而不是原本的IP地址。这样做可以帮助您隐藏真实的IP地址并实现匿名上网，同时提供加密保护，确保您的网络流量在传输过程中得到安全保护。同时，当我们关闭VPN后，由于电脑IP地址任然为VPN分配的IP地址（而此时我们已经关闭了代理服务器的连接），这就导致我们无法正常访问互联网了。\n参考：使用vpn/代理后无法正常上网\n","date":"2025-04-10T20:18:22+08:00","permalink":"https://xxcjw.github.io/p/%E4%BB%A3%E7%90%86-%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98/","title":"代理 \u0026 联网问题"},{"content":"最常用 1 2 3 4 5 6 7 8 9 10 win + l #快速锁屏 ctrl + f #查找 alt + tab #切换页面 win + v #粘贴板 win + space #切换中英文 shift + delete #完全删除文件 tab #选中多行按tab一起缩进 shift + tab #多行取消缩进 ctrl + alt + . #黑屏时可关机、打开任务管理器 ctrl + alt + delete #黑屏时可关机、打开任务管理器 截图快捷键\n1 2 3 win + shift + s #自带截图 alt + z #截图软件截图 alt + a #微信截图 命令行类命令 系统信息查看类 1 2 3 4 5 6 nvidia-smi #查看gpu使用情况 ipconfig #显示ip地址信息 watch -n 1 nvidia-smi #动态追踪查看显存占用 ping xxx #查看本机能否连通某网址 free -h #查看服务器内存（Mem-物理内存，Swap-交换空间） df -h #查看服务器外存/硬盘使用情况（use%表示使用率） 会话管理指令 1 2 3 4 5 screen -S xxxx #创建会话，如screen -S test ctrl+a d #退出会话同时保持程序运行(按住Ctrl，依次再按a,d) screen -r xxxx #恢复会话，如screen -r test exit / ctrl+d #关闭会话，会提示：screen is terminating screen -ls #列出当前存在的会话列表 文件目录操作类 1 2 3 4 5 6 7 8 9 10 ⬆/⬇ #切换历史命令 cd ./xx #切换到某某文件夹 pwd #显示当前工作目录的完整路径 ls #列出当前目录中的文件（-l、-a） source xxx #在当前会话中执行某个脚本，使其立即生效 mkdir xxx #创建一个新目录 rmdir xxx #删除空目录（-p 一次删除多个空文件夹；-r 递归删除） rm xxx #删除不为空的文件或目录（-r递归删除，常用在目录删除） cp source destination #复制文件或目录到指定文件夹下 mv source destination #移动文件或目录 进程管理类 1 2 3 4 5 6 7 8 ps -p \u0026lt;PID\u0026gt; #查看进程信息（看不到使用者） ps -f -p \u0026lt;PID\u0026gt; #查看进程详细信息（f表示full，全部信息） kill \u0026lt;PID\u0026gt; #根据进程号杀死进程 kill -9 \u0026lt;PID\u0026gt; #强制杀死进程 top #实时监控系统中各个进程的资源占用情况 shutdown -h now #服务器立刻关机 shutdown -h 10 #10 分钟后自动关机 shutdown -r now #重启（=reboot也是重启） 文本处理类 1 2 3 4 5 grep \u0026#34;Hello\u0026#34; xx.txt #文本搜索指令，从txt文件中搜索包含指定字符串的行 grep -i \u0026#34;hello\u0026#34; xx.txt #忽略大小写搜索 grep -r \u0026#34;hello\u0026#34; /data #递归搜索，在一个目录搜索包含指定字符串的行 grep -n \u0026#34;Hello\u0026#34; xx.txt #显示匹配行的行号 grep -inr \u0026#34;hello\u0026#34; . #组合使用，点代表在当前目录下搜索 权限管理类 1 2 3 4 5 6 7 ls -l #列出当前目录中的文件以及权限（别称：ll） --------------------通过符号修改权限------------------- chmod u=rwx,g=rx,o=x xxx #对xxx文件夹的所有者、所属组和其他人修改权限 chmod g+w test.txt #对txt文件的所属组添加写的权限 chmod a-x test #对test文件夹的所有用户去除执行的权限（a表示所有人，即u+g+o） --------------------通过数字修改权限------------------- chmod 751 test #等价于chmod u=rwx,g=rx,o=x xxx（7 = rwx = 4+2+1，以此类推） 浏览器快捷键 1 2 3 4 5 ctrl + l #定位到地址栏（可通过设置后，通过应用快速打开某程序） ctrl + t #新建标签页 ctrl + shift + t #重新打开刚才关闭的标签页 ctrl + tab #切换标签页 ctrl + n #打开一个新的浏览器窗口 typora快捷键 1 2 3 4 5 6 7 ``` #插入代码块 $$ #插入公式 enter/shift + enter #不一样的换行方式 ctrl + t #新建表格 ctrl + enter #表格插入行 ctrl + shift + back #删除表格指定行 []() #插入链接（前面加个“!”就是插入图片） vim快捷键 1 2 3 :q #退出（如果有更改不会保存） :wq #保存并退出 :q! #强制退出并丢弃未保存的更改 补充 \u0026amp; 参考 chmod 命令 （change mode）：修改文件或目录的权限\nchown 和 chgrp：修改文件拥有者或所属组\n格式：chmod [选项] 权限 文件名\n权限的本质就是可以干什么，权限=角色（user、group、others）+目标权限属性（rwx）。\nLinux下包含两种用户：超级用户（root）和普通用户。在 Linux 中的每个用户必须属于一个组，不能独立于组外 在 Linux 中每个文件有所有者、所在组、其它组的概念 所有者-User：文件或目录的创建者 所在组-Group：文件或目录所属的用户组 其他-Others：除了文件所有者和用户组之外的所有人 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 权限的基本介绍(0-9位说明)： 第 0 位确定文件类型(d, - , l , c , b) 第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。---User 第 4-6 位确定所属组（同用户组的）拥有该文件的权限，---Group 第 7-9 位确定其他用户拥有该文件的权限 ---Other 文件类型： - 普通文件；d 目录；l 软链接；c 字符设备；b 硬盘 rwx权限详解： [ r ]代表可读: 可以读取,查看 [ w ]代表可写: 可以修改,如果针对的是文件，则不可以删除；如果针对的是目录，则可以删除 [ x ]代表可执行：可以被执行 可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7 数字含义： 如果是目录，则表示子目录个数；如果是文件，则表示硬链接数量 之后两项： 分别表示文件或目录的所有者和所属组 数字含义： 文件大小(字节)，如果是文件夹，显示 4096 字节 剩余项： 最后修改日期和文件名称 快捷键大全网址：\n快捷键速查表 - 星云导航\n快捷键备忘录\n","date":"2025-04-10T16:30:06+08:00","permalink":"https://xxcjw.github.io/p/%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/","title":"电脑相关指令"},{"content":"文章插入图片 如果想要在文章插入图片，有两种方式：\n方式一： 1 ![name](pic.png) 缺点是这种方式插入的图片不可以调节大小，默认占满页面宽度，很不美观。\n方式二： 1 \u0026lt;img src=\u0026#34;1.png\u0026#34; width=\u0026#34;80%\u0026#34; align=\u0026#34;middle\u0026#34; style=\u0026#34;zoom:60%;\u0026#34; /\u0026gt; 如果是在markdown文件里，是居中且缩放到原图的60%大小，但在网页上居中不起作用。\n方式三： 1 \u0026lt;center\u0026gt;\u0026lt;img src=\u0026#34;1.png\u0026#34; width=\u0026#34;80%\u0026#34; align=\u0026#34;middle\u0026#34; style=\u0026#34;zoom:60%;\u0026#34; /\u0026gt;\u0026lt;/center\u0026gt; 这样就可以实现图片居中且缩放成任意比例。\n友链布局修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 title: 友链 slug: \u0026#34;links\u0026#34; layout: \u0026#34;links\u0026#34; menu: main: weight: -50 params: icon: link comments: false links: - title: GitHub description: 全世界最大的代码托管和开源项目平台. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png sites: - title: GitHub description: 全世界最大的代码托管和开源项目平台. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png 现在想要实现的效果如图所示，即按照类别来划分友链，如何实现呢？\n首先，在content/page/links/index.md文件中新建一个链接名，如links、sites等，然后把想要插入的友链放入； 然后，在layouts/page/links.html文件中写入如下代码。其中，xxxs就是上面的链接名，如links、sites等；类别名就是想要的分类名称，如推荐大佬、科技\u0026amp;论坛； 1 2 3 4 5 6 7 \u0026lt;header\u0026gt; \u0026lt;h2 class=\u0026#34;section-title\u0026#34; style=\u0026#34;margin-bottom: -20px;\u0026#34;\u0026gt;类别名\u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{ if .Params.xxxs }} {{ partial \u0026#34;article/components/xxxs\u0026#34; . }} {{ end }} 最后，在layouts/partials/article/components文件下新建xxxs.html文件，文件不存在的就复制一下其他的（代码如下），然后将旧链接名修改为新建的链接名； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;div class=\u0026#34;article-list--compact links\u0026#34;\u0026gt; {{ range $i, $hugo := .Params.hugos }} \u0026lt;article\u0026gt; \u0026lt;a href=\u0026#34;{{ $hugo.website }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- $hugo.title -}} \u0026lt;/h2\u0026gt; \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; {{ with $hugo.description }} {{ . }} {{ else }} {{ $hugo.website }} {{ end }} \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; {{ with $hugo.image }} {{ $permalink := . }} {{ with ($.Resources.GetMatch (printf \u0026#34;%s\u0026#34; (. | safeURL))) }} {{ $permalink = .RelPermalink }} {{ end }} \u0026lt;div class=\u0026#34;article-image\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $permalink }}\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; {{ end }} \u0026lt;/div\u0026gt; 文章内链跳转 写文章的时候总有一个需求就是关联之前写的文章，那么在hugo中应该要怎么用呢？\n方法一：markdown语法\n使用[]()创建链接，比如hugo常用命令。此方法缺点就是文章标题和链接变了，所有地方都需要手动修改。在测试的时候甚至会出现点击后会出现404找不到界面。\n方法二：hugo提供的ref功能\n用法如下所示（哈哈去掉），此方法的好处就是文章的链接变了，这里会跟着变的，不需要手动修改。缺点是文章的标题不能同步变化。hugo常用命令\n建议使用绝对路径（根目录为content目录），而非相对路径，否则容易出错 只有所引用的文件与当前文件在同一文件夹下时可以使用相对路径的方式（只有文件名） 1 [hugo常用命令]({{哈哈\u0026lt; ref \u0026#34;/post/2025-04/hugo快捷命令.md\u0026#34; \u0026gt;}}) 文章内容管理 本文按时间线进行内容管理，其目录结构如下，需要注意以下几点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 content/ └── post ├── 2025-01 │ ├── hugo博客搭建.md │ ├── git常用命令.md │ └── tools文件夹 │ ├── 1.jpg │ ├── 2.jpg │ ├── 3.png │ ├── index.md │ └── 4.png │ ├── 2025-02 │ ├── 博客搭建1.md │ ├── 博客搭建2.md │ ├── 博客搭建3.md │ ├── 博客搭建4.md │ ├── 博客搭建5.md │ ├── 博客搭建6.md │ ├── 博客搭建7.md │ ├── 博客搭建8.md │ ├── 博客搭建9.md │ └── 人生意义.md └── 博客搭建10 ├── index.md └── 博客记录说明 ├── 1.png ├── 2.png ├── 3.png ├── 4.png ├── 5.png ├── 6.png ├── 7.png ├── 8.png ├── 9.png ├── index.zh-cn.md └── index.zh-tw.md post目录下先按照年份建立子目录， 也可以按照 年/月，或者 年/月/日建立 没有图片的文章直接在一级子目录下保存 有图片的多建一级目录, md文件命名为index.lang.md(使用其他命名文件，图片不能显示), 图片放在同一目录/子文件夹 不同语言的md文件，放在一起，统一用不同的index.lang.md区分， 比如 index.zh-cn.md, index.zh-tw.md Bug问题 输入公式时（$$$$），必须空一行才能正常显示（markdown换行enter是区分段落，源代码默认会有一个空行，粘贴复制过来的文字可能是shift+enter换行，导致不是enter换行）。行内插入公式时使用$xxx$表示 加粗时，加粗的内容不能以符号结尾，否则在渲染时出错 Markdown 开源文档\n致谢 1、博客搭建教程\n简单来说，分为几步：\n下载解压hugo压缩包，cmd 打开命令行窗口，输入hugo new site xxxx创建文件（这里是dev） 复制hugo.exe文件到dev文件内 进入hugo官网，下载stack主题压缩包，将文件解压存储在dev\\themes文件下 将 exampleSite 样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml 在dev文件夹，输入hugo server -D，发现已经正确显示 Github Action自动部署 莱特雷-letere\nHugo+Github博客部署\n使用 Hugo + Github Pages 部署个人博客\n2、修改美化\n首先修改dev文件夹下的hugo.yaml文件 其次，主要修改的是assets、layouts、static文件夹，换新电脑时可以直接复制过去 assets/scss/custom.scss文件修改的是大部分美化样式 layouts/_default/single.html文件修改的是：如果文章有目录，则把左侧边栏换为一个返回主页的按钮，如果文章没有目录，则启用左侧边栏 layouts/page文件夹和layouts/partials文件夹修改的是友链分类相关的文件 layouts/index.html文件修改的是：添加了首页欢迎字符面板 themes/hugo-theme-stack/layouts/partials/article/components/details.html文件修改的是：添加文章字数统计功能；而该文件夹下footer.html修改的是：添加了一行代码以及新建categories.html文件实现在文章末尾也显示分类标签 themes/hugo-theme-stack/layouts/partials/footer/footer.html删除了页脚信息，更简洁 themes/hugo-theme-stack/layouts/partials/article/components/related-content.html整个文件删除或注释，这样文章底部就不会显示相关文章了 assets/scss/partials文件夹以及layouts/partials/footer文件夹修改内容：添加博客运行时间以及样式 Stack 魔改美化-Naive Koala-2篇\nHugo Stack 主题美化-阿琦同学-很全-2篇\nL1nSn0wの小窝 - Stack主题的自定义\nHugo的Stack主题美化零碎-wfg\n使用 Hugo 对博客的重建与 Stack 主题优化记录-Exnadio\u0026rsquo;s Blog\nStack 主题的自定义-折腾日记\nHugo Stack 主题配置与使用 | Bore\u0026rsquo;s Notes\nHugo博客 | stack主题修改第一站-墨纹\nHugo Stack主题装修笔记-博客运行时间\nLeonus 博客\n张洪Heo - 分享设计与科技生活\n安知鱼 - 生活明朗 万物可爱\nHugo Theme Cybe\n3、图标网站\n打开stack官方文档Stack 官方文档，在``Custom Menu`栏下可以找到推荐的图标网站\nIcons网站\n","date":"2025-04-08T22:53:36+08:00","permalink":"https://xxcjw.github.io/p/stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/","title":"Stack主题修改"},{"content":"创建文章 1 hugo new post/xxx/xxx.md 预览网站 1 2 hugo server -D hugo server 两者都是用于启动 Hugo 本地开发服务器的命令，区别主要在于是否包含草稿文章方面：\nhugo server：启动一个本地开发服务器，该服务器会对项目文件的变更进行监控，一旦文件有改动，就会实时重新生成网站。不过，在生成网站内容时，它默认不会包含草稿文章。 hugo server -D：-D 是 --buildDrafts 的简写。样会启动本地开发服务器，实现对文件变更的监控和网站的实时更新与刷新。不同的是，在生成网站时会将草稿文章也包含进去。 清除缓存 1 2 3 hugo --gc hugo --gc --minify hugo server --gc -D 当预览修改文章时，发现页面没变化，可以尝试清除缓存并重新构建：\nhugo --gc：--gc 标志的作用是在构建过程中执行垃圾回收（Garbage Collection），即清除不再使用的缓存文件，这样能释放磁盘空间。如果对网站配置或内容进行了大量修改，旧的缓存不再使用，该命令能保证生成的网站是最新状态。 hugo --gc --minify：除了具备执行垃圾回收功能外，--minify 标志还会对生成的 HTML、CSS、JavaScript 等文件进行压缩。可以减小文件大小，从而提升网站的加载速度。适合在准备将网站部署到生产环境时使用，能提供更流畅的访问体验。 hugo server --gc -D：启动一个实时预览服务器，同时执行垃圾回收，确保使用的是最新的缓存。适合在开发过程中使用，当频繁修改文章内容，并希望随时预览草稿文章在内的网站效果时最方便。 发布文章 1 2 3 4 5 git init git add . git commit -m \u0026#34;xxx\u0026#34; git remote add origin {github仓库地址} git push -u origin main git init：初始化一个新的 Git 仓库，会将当前目录变为一个Git仓库。并生成一个名为 .git 的隐藏目录，包含了 Git 管理项目所需的各种配置文件和数据结构。 git add .：用于把文件的修改添加到暂存区。可以在暂存区（Git中的一个中间区域）组织和规划哪些修改要包含在下次提交中。. 代表当前目录下的所有文件和子目录。 git commit -m \u0026quot;xxx\u0026quot;：用于将暂存区的修改保存到本地仓库的历史记录中，-m 标志后面跟着的 \u0026quot;xxx\u0026quot; 是本次提交的说明信息。 git remote add origin xxx：用于管理与远程仓库（一般是GitHub创建的远仓）的连接。add 子命令用于添加一个新的远程仓库。origin 是远程仓库的默认名。这会将本地仓库与该 GitHub 仓库建立连接。 git push -u origin main：用于将本地仓库的提交推送到远程仓库。-u会将本地的 main 分支与远程仓库的 main 分支关联起来，这样在后续的推送操作中，你只需要执行 git push 即可。origin 是远程仓库的别名，main 是要推送的本地分支名称。 1 2 git push git push -u origin main git push -u origin main：除了将本地的 main 分支推送到远程 origin 仓库的 main 分支外，还会建立本地 main 分支和远程 origin/main 分支的关联。建立关联后，后续使用 git push 或 git pull 时，Git 会知道默认操作的远程分支。通常在首次将本地分支推送到远程仓库时使用，这样后续无需每次都指定远程仓库和分支。 git push：如果本地分支已经和远程分支建立了关联，使用该命令可以简化操作，快速将本地更新推送到远程。适合在本地分支和远程分支已经建立关联的情况下。 其他 1 git remote -v 查看本地仓库与哪些远程仓库进行了连接的命令。执行该命令后，会列出本地仓库所关联的所有远程仓库的别名以及对应的远程仓库的 URL 地址。这里会展示 fetch（拉取）和 push（推送）对应的地址，一般情况下二者是相同的。\n1 hugo version 查看hugo版本，我的是0.145版本。\n","date":"2025-04-08T08:37:54+08:00","permalink":"https://xxcjw.github.io/p/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Hugo常用命令"},{"content":"1、接好 11111\n2、和黑 1 jaba $x_a$+1\n豆包\n","date":"2025-04-07T09:12:42+08:00","permalink":"https://xxcjw.github.io/p/%E5%A4%A7%E6%A8%A1%E5%9E%8B/","title":"大模型"}]